
import { useEffect, useState, useCallback } from "react";
import { Search, AlertTriangle, RefreshCw, Check, Brain, FileText, Code } from "lucide-react";
import { Progress } from "@/components/ui/progress";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Slider } from "@/components/ui/slider";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { useAuth } from "@/contexts/AuthContext";

interface PlagiarismDetectorProps {
  files: File[];
  onPlagiarismDetected?: (result: {
    isDuplicate: boolean;
    similarity: number;
    fileName: string;
    matchDetails?: {
      matchedSections: { text: string; similarity: number }[];
      source: string;
    }[];
  }) => void;
}

interface FileHash {
  name: string;
  hash: string;
  type: string;
  content?: string;
  createdAt: number;
  userId: string;
}

interface FileSection {
  text: string;
  index: number;
  type: "text" | "code" | "equation";
}

const PlagiarismDetector = ({ files, onPlagiarismDetected }: PlagiarismDetectorProps) => {
  const { user } = useAuth();
  const [isChecking, setIsChecking] = useState(false);
  const [progress, setProgress] = useState(0);
  const [results, setResults] = useState<{
    fileName: string;
    isDuplicate: boolean;
    similarity: number;
    matchDetails?: {
      matchedSections: { text: string; similarity: number }[];
      source: string;
    }[];
  }[]>([]);
  const [fileHashes, setFileHashes] = useState<FileHash[]>([]);
  const [sensitivityThreshold, setSensitivityThreshold] = useState(80);
  const [isOpen, setIsOpen] = useState(false);
  const [advancedOptions, setAdvancedOptions] = useState({
    ignoreBoilerplate: true,
    checkCode: true,
    checkEquations: true,
    semanticAnalysis: true,
    ignoreOwnDocuments: false
  });

  // Function to extract text from files using PDF.js or other library
  const extractText = async (file: File): Promise<string> => {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        // For demo purposes, we're using file content directly
        // In a real implementation, you would use PDF.js or another library
        // to extract the text from PDFs
        if (e.target?.result) {
          const content = e.target.result;
          resolve(String(content));
        } else {
          resolve("");
        }
      };
      reader.readAsText(file);
    });
  };

  // Simulated BERT embeddings - in a real app, this would use a JS port of transformers
  // or make an API call to a backend service
  const createEmbedding = (text: string): number[] => {
    // Simulate a 100-dimensional embedding vector
    // In a real system, this would be generated by a BERT model
    return Array.from({ length: 100 }, () => Math.random());
  };

  // Calculate cosine similarity between two vectors
  const cosineSimilarity = (a: number[], b: number[]): number => {
    if (a.length !== b.length) return 0;
    
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    
    normA = Math.sqrt(normA);
    normB = Math.sqrt(normB);
    
    if (normA === 0 || normB === 0) {
      return 0;
    }
    
    return (dotProduct / (normA * normB)) * 100;
  };

  // Calculate a simple hash from text
  const calculateHash = (text: string): string => {
    let hash = 0;
    for (let i = 0; i < text.length; i++) {
      hash = ((hash << 5) - hash) + text.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return hash.toString(16);
  };

  // Divide text into sections
  const sectionizeText = (text: string): FileSection[] => {
    // In a real implementation, this would identify different sections
    // like abstract, introduction, etc., and also detect code/equations
    const sections: FileSection[] = [];
    
    // Simple implementation - split by paragraphs
    const paragraphs = text.split('\n\n');
    
    paragraphs.forEach((paragraph, index) => {
      if (paragraph.trim()) {
        // Simple detection of code (looks for common programming keywords)
        const isCode = /\b(function|class|import|const|var|let|if|for|while|return)\b/.test(paragraph);
        
        // Simple detection of equations (looks for LaTeX-like notation)
        const isEquation = /\$|\\begin{equation}|\\frac|\\sum|\\int/.test(paragraph);
        
        sections.push({
          text: paragraph,
          index,
          type: isCode ? "code" : isEquation ? "equation" : "text"
        });
      }
    });
    
    return sections;
  };

  // Compare sections based on their type (text, code, equation)
  const compareSections = (
    section1: FileSection,
    section2: FileSection,
    useSemanticAnalysis: boolean
  ): number => {
    // If types don't match, comparison is less relevant
    if (section1.type !== section2.type) return 0;
    
    // For text, use semantic analysis if enabled
    if (section1.type === "text" && useSemanticAnalysis) {
      const embedding1 = createEmbedding(section1.text);
      const embedding2 = createEmbedding(section2.text);
      return cosineSimilarity(embedding1, embedding2);
    }
    
    // For code, use a more code-specific comparison
    if (section1.type === "code") {
      // Normalize code by removing whitespace and variable names
      const normalized1 = section1.text
        .replace(/\s+/g, '')
        .replace(/[a-zA-Z_][a-zA-Z0-9_]*/g, 'VAR');
      
      const normalized2 = section2.text
        .replace(/\s+/g, '')
        .replace(/[a-zA-Z_][a-zA-Z0-9_]*/g, 'VAR');
      
      // Calculate Levenshtein distance
      const distance = levenshteinDistance(normalized1, normalized2);
      const maxLength = Math.max(normalized1.length, normalized2.length);
      return maxLength > 0 ? (1 - distance / maxLength) * 100 : 0;
    }
    
    // For equations and other types, use direct comparison
    const similarity = levenshteinDistance(section1.text, section2.text);
    const maxLength = Math.max(section1.text.length, section2.text.length);
    return maxLength > 0 ? (1 - similarity / maxLength) * 100 : 0;
  };
  
  // Levenshtein distance for string similarity
  const levenshteinDistance = (a: string, b: string): number => {
    const matrix: number[][] = [];
    
    // Initialize the matrix
    for (let i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }
    
    // Fill the matrix
    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1, // substitution
            matrix[i][j - 1] + 1,     // insertion
            matrix[i - 1][j] + 1      // deletion
          );
        }
      }
    }
    
    return matrix[b.length][a.length];
  };

  // Compare files for plagiarism
  const compareFiles = async (
    currentFile: { content: string; name: string },
    previousFiles: FileHash[],
    options: typeof advancedOptions
  ) => {
    const currentSections = sectionizeText(currentFile.content);
    
    // Filter by document type
    const relevantPreviousFiles = previousFiles.filter(file => {
      // Filter based on advanced options
      if (options.ignoreOwnDocuments && file.userId === user?.id) {
        return false;
      }
      return file.content;
    });
    
    const allMatches: {
      matchedSections: { text: string; similarity: number }[];
      source: string;
      overallSimilarity: number;
    }[] = [];
    
    for (const prevFile of relevantPreviousFiles) {
      if (prevFile.name === currentFile.name) continue; // Skip same file
      
      if (prevFile.content) {
        const prevSections = sectionizeText(prevFile.content);
        const sectionMatches: { text: string; similarity: number }[] = [];
        
        // Compare each section
        for (const currentSection of currentSections) {
          // Skip boilerplate if option is enabled
          if (options.ignoreBoilerplate && isBoilerplate(currentSection.text)) {
            continue;
          }
          
          // Skip code sections if checkCode is disabled
          if (currentSection.type === "code" && !options.checkCode) {
            continue;
          }
          
          // Skip equations if checkEquations is disabled
          if (currentSection.type === "equation" && !options.checkEquations) {
            continue;
          }
          
          // Find best matching section in previous file
          let bestMatch = { similarity: 0, section: prevSections[0] };
          
          for (const prevSection of prevSections) {
            const similarity = compareSections(
              currentSection, 
              prevSection, 
              options.semanticAnalysis
            );
            
            if (similarity > bestMatch.similarity) {
              bestMatch = { similarity, section: prevSection };
            }
          }
          
          // If similarity is high enough, add to matches
          if (bestMatch.similarity > (sensitivityThreshold / 2)) {
            sectionMatches.push({
              text: currentSection.text,
              similarity: bestMatch.similarity
            });
          }
        }
        
        // Calculate overall similarity
        const overallSimilarity = sectionMatches.length > 0
          ? sectionMatches.reduce((sum, match) => sum + match.similarity, 0) / sectionMatches.length
          : 0;
        
        if (sectionMatches.length > 0) {
          allMatches.push({
            matchedSections: sectionMatches,
            source: prevFile.name,
            overallSimilarity
          });
        }
      }
    }
    
    // Sort matches by similarity
    allMatches.sort((a, b) => b.overallSimilarity - a.overallSimilarity);
    
    // Calculate final similarity score (highest match)
    const highestSimilarity = allMatches.length > 0 ? allMatches[0].overallSimilarity : 0;
    const isDuplicate = highestSimilarity > sensitivityThreshold;
    
    // Format for return
    return {
      fileName: currentFile.name,
      isDuplicate,
      similarity: Math.round(highestSimilarity),
      matchDetails: allMatches.length > 0 ? allMatches.map(match => ({
        matchedSections: match.matchedSections,
        source: match.source
      })) : undefined
    };
  };
  
  // Detect boilerplate text
  const isBoilerplate = (text: string): boolean => {
    // Detect common boilerplate elements
    const boilerplatePatterns = [
      /references|bibliography/i,
      /table of contents/i,
      /page \d+ of \d+/i,
      /submitted in partial fulfillment/i,
      /all rights reserved/i,
      /copyright/i,
      /acknowledgements/i
    ];
    
    return boilerplatePatterns.some(pattern => pattern.test(text));
  };

  // Check for plagiarism across files
  const checkForPlagiarism = useCallback(async () => {
    if (files.length === 0) return;
    
    setIsChecking(true);
    setProgress(0);
    
    // Get local storage for previously uploaded files using user-specific prefix
    const userPrefix = localStorage.getItem("currentUserPrefix") || "";
    const storedHashes = localStorage.getItem(`${userPrefix}timeVaultFileHashes`);
    const previousHashes: FileHash[] = storedHashes ? JSON.parse(storedHashes) : [];
    
    const newResults = [];
    const newHashes = [];
    
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      
      // Only check PDFs and documents
      if (!file.type.includes("pdf") && 
          !file.type.includes("doc") && 
          !file.type.includes("application/vnd.openxmlformats-officedocument")) {
        setProgress(((i + 1) / files.length) * 100);
        continue;
      }
      
      // Extract text content
      const content = await extractText(file);
      
      // Calculate hash for current file
      const hash = calculateHash(content);
      
      newHashes.push({ 
        name: file.name, 
        hash, 
        type: file.type, 
        content,
        createdAt: Date.now(),
        userId: user?.id || "anonymous"
      });
      
      // Enhanced comparison with previous files
      const result = await compareFiles(
        { content, name: file.name },
        previousHashes,
        advancedOptions
      );
      
      newResults.push(result);
      
      // Notify parent component if plagiarism detected
      if (result.isDuplicate && onPlagiarismDetected) {
        onPlagiarismDetected(result);
      }
      
      // Update progress
      setProgress(((i + 1) / files.length) * 100);
      
      // Small delay to visualize progress
      await new Promise(r => setTimeout(r, 200));
    }
    
    // Save results
    setResults(newResults);
    
    // Store new hashes in localStorage (without the content to save space)
    const hashesForStorage = newHashes.map(({ content, ...rest }) => rest);
    const combinedHashes = [...previousHashes, ...hashesForStorage];
    
    // De-duplicate hashes by name+hash
    const uniqueHashes = combinedHashes.filter((hash, index, self) => 
      index === self.findIndex(h => h.hash === hash.hash && h.name === hash.name)
    );
    
    localStorage.setItem(`${userPrefix}timeVaultFileHashes`, JSON.stringify(uniqueHashes));
    setFileHashes(newHashes);
    
    setIsChecking(false);
    setProgress(100);
  }, [files, onPlagiarismDetected, advancedOptions, sensitivityThreshold, user]);

  // Run check when files change
  useEffect(() => {
    if (files.length > 0) {
      checkForPlagiarism();
    }
  }, [files, checkForPlagiarism]);

  // No UI if no files
  if (files.length === 0) return null;

  const duplicateCount = results.filter(r => r.isDuplicate).length;

  return (
    <div className="rounded-md border border-border p-4 bg-background/50 backdrop-blur-sm">
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-2">
          <Search className="h-4 w-4 text-primary" />
          <h3 className="text-sm font-medium">Advanced Plagiarism Detection</h3>
        </div>
        
        <Badge variant={duplicateCount > 0 ? "destructive" : "outline"}>
          {isChecking ? (
            <span className="flex items-center gap-1">
              <RefreshCw className="h-3 w-3 animate-spin" />
              Checking
            </span>
          ) : duplicateCount > 0 ? (
            <span className="flex items-center gap-1">
              <AlertTriangle className="h-3 w-3" />
              {duplicateCount} Duplicate{duplicateCount > 1 ? "s" : ""}
            </span>
          ) : (
            <span className="flex items-center gap-1">
              <Check className="h-3 w-3" />
              No Duplicates
            </span>
          )}
        </Badge>
      </div>
      
      {/* Sensitivity slider */}
      <div className="mb-4">
        <div className="flex items-center justify-between mb-2">
          <span className="text-xs font-medium">Detection Sensitivity</span>
          <span className="text-xs">{sensitivityThreshold}%</span>
        </div>
        <Slider
          value={[sensitivityThreshold]}
          min={50}
          max={95}
          step={5}
          onValueChange={(values) => setSensitivityThreshold(values[0])}
          disabled={isChecking}
        />
      </div>
      
      {/* Advanced options collapsible */}
      <Collapsible
        open={isOpen}
        onOpenChange={setIsOpen}
        className="mb-4 space-y-2 border-t border-b py-2 border-border"
      >
        <div className="flex items-center justify-between">
          <span className="text-xs font-medium flex items-center gap-1">
            <Brain className="h-3 w-3" />
            Advanced Detection Options
          </span>
          <CollapsibleTrigger asChild>
            <button className="text-xs text-primary hover:underline">
              {isOpen ? "Hide Options" : "Show Options"}
            </button>
          </CollapsibleTrigger>
        </div>
        
        <CollapsibleContent className="space-y-2 pt-2">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Switch
                id="ignoreBoilerplate"
                checked={advancedOptions.ignoreBoilerplate}
                onCheckedChange={(checked) => 
                  setAdvancedOptions({...advancedOptions, ignoreBoilerplate: checked})
                }
              />
              <Label htmlFor="ignoreBoilerplate" className="text-xs">Ignore Boilerplate</Label>
            </div>
            <Badge variant="outline" className="text-xs">References, Headers</Badge>
          </div>
          
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Switch
                id="checkCode"
                checked={advancedOptions.checkCode}
                onCheckedChange={(checked) => 
                  setAdvancedOptions({...advancedOptions, checkCode: checked})
                }
              />
              <Label htmlFor="checkCode" className="text-xs">Check Code</Label>
            </div>
            <Badge variant="outline" className="text-xs flex items-center gap-1">
              <Code className="h-3 w-3" />
              AST Analysis
            </Badge>
          </div>
          
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Switch
                id="checkEquations"
                checked={advancedOptions.checkEquations}
                onCheckedChange={(checked) => 
                  setAdvancedOptions({...advancedOptions, checkEquations: checked})
                }
              />
              <Label htmlFor="checkEquations" className="text-xs">Check Equations</Label>
            </div>
            <Badge variant="outline" className="text-xs">LaTeX Support</Badge>
          </div>
          
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Switch
                id="semanticAnalysis"
                checked={advancedOptions.semanticAnalysis}
                onCheckedChange={(checked) => 
                  setAdvancedOptions({...advancedOptions, semanticAnalysis: checked})
                }
              />
              <Label htmlFor="semanticAnalysis" className="text-xs">Semantic Analysis</Label>
            </div>
            <Badge variant="outline" className="text-xs flex items-center gap-1">
              <Brain className="h-3 w-3" />
              BERT-like
            </Badge>
          </div>
          
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Switch
                id="ignoreOwnDocuments"
                checked={advancedOptions.ignoreOwnDocuments}
                onCheckedChange={(checked) => 
                  setAdvancedOptions({...advancedOptions, ignoreOwnDocuments: checked})
                }
              />
              <Label htmlFor="ignoreOwnDocuments" className="text-xs">Ignore Own Documents</Label>
            </div>
            <Badge variant="outline" className="text-xs">Version Aware</Badge>
          </div>
        </CollapsibleContent>
      </Collapsible>
      
      {isChecking ? (
        <div className="space-y-2">
          <div className="flex justify-between text-xs text-muted-foreground">
            <span>Processing document analysis...</span>
            <span>{Math.round(progress)}%</span>
          </div>
          <Progress value={progress} className="h-2" />
        </div>
      ) : results.some(r => r.isDuplicate) ? (
        <Alert variant="destructive" className="bg-destructive/10 text-destructive border-destructive/20">
          <AlertTriangle className="h-4 w-4" />
          <AlertTitle>Potential Plagiarism Detected</AlertTitle>
          <AlertDescription>
            <div className="space-y-2">
              {results.filter(r => r.isDuplicate).map((result, i) => (
                <div key={i} className="text-sm mt-1">
                  <div className="font-medium">{result.fileName} - {result.similarity}% similarity</div>
                  {result.matchDetails && result.matchDetails.length > 0 && (
                    <div className="mt-1 pl-4 border-l-2 border-destructive/30 text-xs">
                      <span className="font-medium">Matched with: </span>
                      {result.matchDetails[0].source}
                      {result.matchDetails[0].matchedSections.length > 0 && (
                        <div className="mt-1 pl-2 text-xs opacity-80 max-h-20 overflow-y-auto">
                          "{result.matchDetails[0].matchedSections[0].text.substring(0, 100)}..."
                        </div>
                      )}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </AlertDescription>
        </Alert>
      ) : (
        <div className="text-sm text-muted-foreground flex items-center gap-2">
          <div className="p-1 bg-green-100 dark:bg-green-900/30 rounded-full">
            <Check className="h-3 w-3 text-green-600 dark:text-green-400" />
          </div>
          No duplicates detected among {files.filter(f => 
            f.type.includes("pdf") || 
            f.type.includes("doc") || 
            f.type.includes("application/vnd.openxmlformats-officedocument")
          ).length} document{files.length > 1 ? "s" : ""}.
        </div>
      )}
      
      <div className="flex items-start gap-2 mt-4 bg-blue-50 dark:bg-blue-950/30 p-2 rounded-sm">
        <FileText className="h-4 w-4 text-blue-500 mt-0.5" />
        <div className="text-xs text-blue-700 dark:text-blue-400">
          <p>This feature performs advanced semantic analysis to detect plagiarism across documents. 
          Cross-references content with previous uploads, looking for both exact matches and paraphrased content.</p>
        </div>
      </div>
    </div>
  );
};

export default PlagiarismDetector;
